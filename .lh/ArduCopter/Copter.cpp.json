{
    "sourceFile": "ArduCopter/Copter.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1676872580365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1676872580364,
            "name": "Commit-0",
            "content": "/*\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n *  ArduCopter (also known as APM, APM:Copter or just Copter)\n *  Wiki:           copter.ardupilot.org\n *  Creator:        Jason Short\n *  Lead Developer: Randy Mackay\n *  Lead Tester:    Marco Robustini\n *  Based on code and ideas from the Arducopter team: Leonard Hall, Andrew Tridgell, Robert Lefebvre, Pat Hickey, Michael Oborne, Jani Hirvinen,\n                                                      Olivier Adler, Kevin Hester, Arthur Benemann, Jonathan Challinger, John Arne Birkeland,\n                                                      Jean-Louis Naudin, Mike Smith, and more\n *  Thanks to: Chris Anderson, Jordi Munoz, Jason Short, Doug Weibel, Jose Julio\n *\n *  Special Thanks to contributors (in alphabetical order by first name):\n *\n *  Adam M Rivera       :Auto Compass Declination\n *  Amilcar Lucas       :Camera mount library\n *  Andrew Tridgell     :General development, Mavlink Support\n *  Andy Piper          :Harmonic notch, In-flight FFT, Bi-directional DShot, various drivers\n *  Angel Fernandez     :Alpha testing\n *  AndreasAntonopoulous:GeoFence\n *  Arthur Benemann     :DroidPlanner GCS\n *  Benjamin Pelletier  :Libraries\n *  Bill King           :Single Copter\n *  Christof Schmid     :Alpha testing\n *  Craig Elder         :Release Management, Support\n *  Dani Saez           :V Octo Support\n *  Doug Weibel         :DCM, Libraries, Control law advice\n *  Emile Castelnuovo   :VRBrain port, bug fixes\n *  Gregory Fletcher    :Camera mount orientation math\n *  Guntars             :Arming safety suggestion\n *  HappyKillmore       :Mavlink GCS\n *  Hein Hollander      :Octo Support, Heli Testing\n *  Igor van Airde      :Control Law optimization\n *  Jack Dunkle         :Alpha testing\n *  James Goppert       :Mavlink Support\n *  Jani Hiriven        :Testing feedback\n *  Jean-Louis Naudin   :Auto Landing\n *  John Arne Birkeland :PPM Encoder\n *  Jose Julio          :Stabilization Control laws, MPU6k driver\n *  Julien Dubois       :PosHold flight mode\n *  Julian Oes          :Pixhawk\n *  Jonathan Challinger :Inertial Navigation, CompassMot, Spin-When-Armed\n *  Kevin Hester        :Andropilot GCS\n *  Max Levine          :Tri Support, Graphics\n *  Leonard Hall        :Flight Dynamics, Throttle, Loiter and Navigation Controllers\n *  Marco Robustini     :Lead tester\n *  Michael Oborne      :Mission Planner GCS\n *  Mike Smith          :Pixhawk driver, coding support\n *  Olivier Adler       :PPM Encoder, piezo buzzer\n *  Pat Hickey          :Hardware Abstraction Layer (HAL)\n *  Robert Lefebvre     :Heli Support, Copter LEDs\n *  Roberto Navoni      :Library testing, Porting to VRBrain\n *  Sandro Benigno      :Camera support, MinimOSD\n *  Sandro Tognana      :PosHold flight mode\n *  Sebastian Quilter   :SmartRTL\n *  ..and many more.\n *\n *  Code commit statistics can be found here: https://github.com/ArduPilot/ardupilot/graphs/contributors\n *  Wiki: https://copter.ardupilot.org/\n *\n */\n\n#include \"Copter.h\"\n\n#define FORCE_VERSION_H_INCLUDE\n#include \"version.h\"\n#undef FORCE_VERSION_H_INCLUDE\n\nconst AP_HAL::HAL& hal = AP_HAL::get_HAL();\n\n#define SCHED_TASK(func, _interval_ticks, _max_time_micros, _prio) SCHED_TASK_CLASS(Copter, &copter, func, _interval_ticks, _max_time_micros, _prio)\n\n/*\n  scheduler table - all regular tasks apart from the fast_loop()\n  should be listed here.\n\n  All entries in this table must be ordered by priority.\n\n  This table is interleaved with the table in AP_Vehicle to determine\n  the order in which tasks are run.  Convenience methods SCHED_TASK\n  and SCHED_TASK_CLASS are provided to build entries in this structure:\n\nSCHED_TASK arguments:\n - name of static function to call\n - rate (in Hertz) at which the function should be called\n - expected time (in MicroSeconds) that the function should take to run\n - priority (0 through 255, lower number meaning higher priority)\n\nSCHED_TASK_CLASS arguments:\n - class name of method to be called\n - instance on which to call the method\n - method to call on that instance\n - rate (in Hertz) at which the method should be called\n - expected time (in MicroSeconds) that the method should take to run\n - priority (0 through 255, lower number meaning higher priority)\n\n */\nconst AP_Scheduler::Task Copter::scheduler_tasks[] = {\n    SCHED_TASK(rc_loop,              100,    130,  3),\n    SCHED_TASK(throttle_loop,         50,     75,  6),\n    SCHED_TASK_CLASS(AP_GPS,               &copter.gps,                 update,          50, 200,   9),\n#if AP_OPTICALFLOW_ENABLED\n    SCHED_TASK_CLASS(OpticalFlow,          &copter.optflow,             update,         200, 160,  12),\n#endif\n    SCHED_TASK(update_batt_compass,   10,    120, 15),\n    SCHED_TASK_CLASS(RC_Channels, (RC_Channels*)&copter.g2.rc_channels, read_aux_all,    10,  50,  18),\n    SCHED_TASK(arm_motors_check,      10,     50, 21),\n#if TOY_MODE_ENABLED == ENABLED\n    SCHED_TASK_CLASS(ToyMode,              &copter.g2.toy_mode,         update,          10,  50,  24),\n#endif\n    SCHED_TASK(auto_disarm_check,     10,     50,  27),\n    SCHED_TASK(auto_trim,             10,     75,  30),\n#if RANGEFINDER_ENABLED == ENABLED\n    SCHED_TASK(read_rangefinder,      20,    100,  33),\n#endif\n#if HAL_PROXIMITY_ENABLED\n    SCHED_TASK_CLASS(AP_Proximity,         &copter.g2.proximity,        update,         200,  50,  36),\n#endif\n#if BEACON_ENABLED == ENABLED\n    SCHED_TASK_CLASS(AP_Beacon,            &copter.g2.beacon,           update,         400,  50,  39),\n#endif\n    SCHED_TASK(update_altitude,       10,    100,  42),\n    SCHED_TASK(run_nav_updates,       50,    100,  45),\n    SCHED_TASK(update_throttle_hover,100,     90,  48),\n#if MODE_SMARTRTL_ENABLED == ENABLED\n    SCHED_TASK_CLASS(ModeSmartRTL,         &copter.mode_smartrtl,       save_position,    3, 100,  51),\n#endif\n#if SPRAYER_ENABLED == ENABLED\n    SCHED_TASK_CLASS(AC_Sprayer,           &copter.sprayer,               update,         3,  90,  54),\n#endif\n    SCHED_TASK(three_hz_loop,          3,     75, 57),\n    SCHED_TASK_CLASS(AP_ServoRelayEvents,  &copter.ServoRelayEvents,      update_events, 50,  75,  60),\n    SCHED_TASK_CLASS(AP_Baro,              &copter.barometer,             accumulate,    50,  90,  63),\n#if AC_FENCE == ENABLED\n    SCHED_TASK_CLASS(AC_Fence,             &copter.fence,                 update,        10, 100,  66),\n#endif\n#if PRECISION_LANDING == ENABLED\n    SCHED_TASK(update_precland,      400,     50,  69),\n#endif\n#if FRAME_CONFIG == HELI_FRAME\n    SCHED_TASK(check_dynamic_flight,  50,     75,  72),\n#endif\n#if LOGGING_ENABLED == ENABLED\n    SCHED_TASK(fourhundred_hz_logging,400,    50,  75),\n#endif\n    SCHED_TASK_CLASS(AP_Notify,            &copter.notify,              update,          50,  90,  78),\n    SCHED_TASK(one_hz_loop,            1,    100,  81),\n    SCHED_TASK(ekf_check,             10,     75,  84),\n    SCHED_TASK(check_vibration,       10,     50,  87),\n    SCHED_TASK(gpsglitch_check,       10,     50,  90),\n#if LANDING_GEAR_ENABLED == ENABLED\n    SCHED_TASK(landinggear_update,    10,     75,  93),\n#endif\n    SCHED_TASK(standby_update,        100,    75,  96),\n    SCHED_TASK(lost_vehicle_check,    10,     50,  99),\n    SCHED_TASK_CLASS(GCS,                  (GCS*)&copter._gcs,          update_receive, 400, 180, 102),\n    SCHED_TASK_CLASS(GCS,                  (GCS*)&copter._gcs,          update_send,    400, 550, 105),\n#if HAL_MOUNT_ENABLED\n    SCHED_TASK_CLASS(AP_Mount,             &copter.camera_mount,        update,          50,  75, 108),\n#endif\n#if CAMERA == ENABLED\n    SCHED_TASK_CLASS(AP_Camera,            &copter.camera,              update,          50,  75, 111),\n#endif\n#if LOGGING_ENABLED == ENABLED\n    SCHED_TASK(ten_hz_logging_loop,   10,    350, 114),\n    SCHED_TASK(twentyfive_hz_logging, 25,    110, 117),\n    SCHED_TASK_CLASS(AP_Logger,            &copter.logger,              periodic_tasks, 400, 300, 120),\n#endif\n    SCHED_TASK_CLASS(AP_InertialSensor,    &copter.ins,                 periodic,       400,  50, 123),\n\n    SCHED_TASK_CLASS(AP_Scheduler,         &copter.scheduler,           update_logging, 0.1,  75, 126),\n#if RPM_ENABLED == ENABLED\n    SCHED_TASK_CLASS(AP_RPM,               &copter.rpm_sensor,          update,          40, 200, 129),\n#endif\n    SCHED_TASK_CLASS(Compass, &copter.compass, cal_update, 100, 100, 132),\n    SCHED_TASK_CLASS(AP_TempCalibration,   &copter.g2.temp_calibration, update,          10, 100, 135),\n#if HAL_ADSB_ENABLED\n    SCHED_TASK(avoidance_adsb_update, 10,    100, 138),\n#endif\n#if ADVANCED_FAILSAFE == ENABLED\n    SCHED_TASK(afs_fs_check,          10,    100, 141),\n#endif\n#if AP_TERRAIN_AVAILABLE\n    SCHED_TASK(terrain_update,        10,    100, 144),\n#endif\n#if GRIPPER_ENABLED == ENABLED\n    SCHED_TASK_CLASS(AP_Gripper,           &copter.g2.gripper,          update,          10,  75, 147),\n#endif\n#if WINCH_ENABLED == ENABLED\n    SCHED_TASK_CLASS(AP_Winch,             &copter.g2.winch,            update,          50,  50, 150),\n#endif\n#ifdef USERHOOK_FASTLOOP\n    SCHED_TASK(userhook_FastLoop,    100,     75, 153),\n#endif\n#ifdef USERHOOK_50HZLOOP\n    SCHED_TASK(userhook_50Hz,         50,     75, 156),\n#endif\n#ifdef USERHOOK_MEDIUMLOOP\n    SCHED_TASK(userhook_MediumLoop,   10,     75, 159),\n#endif\n#ifdef USERHOOK_SLOWLOOP\n    SCHED_TASK(userhook_SlowLoop,      3.3,   75, 162),\n#endif\n#ifdef USERHOOK_SUPERSLOWLOOP\n    SCHED_TASK(userhook_SuperSlowLoop, 1,     75, 165),\n#endif\n#if HAL_BUTTON_ENABLED\n    SCHED_TASK_CLASS(AP_Button,            &copter.button,              update,           5, 100, 168),\n#endif\n#if STATS_ENABLED == ENABLED\n    SCHED_TASK_CLASS(AP_Stats,             &copter.g2.stats,            update,           1, 100, 171),\n#endif\n};\n\nvoid Copter::get_scheduler_tasks(const AP_Scheduler::Task *&tasks,\n                                 uint8_t &task_count,\n                                 uint32_t &log_bit)\n{\n    tasks = &scheduler_tasks[0];\n    task_count = ARRAY_SIZE(scheduler_tasks);\n    log_bit = MASK_LOG_PM;\n}\n\nconstexpr int8_t Copter::_failsafe_priorities[7];\n\n// Main loop - 400hz\nvoid Copter::fast_loop()\n{\n    // update INS immediately to get current gyro data populated\n    ins.update();\n\n    // run low level rate controllers that only require IMU data\n    attitude_control->rate_controller_run();\n\n    // send outputs to the motors library immediately\n    motors_output();\n\n    // run EKF state estimator (expensive)\n    // --------------------\n    read_AHRS();\n\n#if FRAME_CONFIG == HELI_FRAME\n    update_heli_control_dynamics();\n    #if MODE_AUTOROTATE_ENABLED == ENABLED\n        heli_update_autorotation();\n    #endif\n#endif //HELI_FRAME\n\n    // Inertial Nav\n    // --------------------\n    read_inertia();\n\n    // check if ekf has reset target heading or position\n    check_ekf_reset();\n\n    // run the attitude controllers\n    update_flight_mode();\n\n    // update home from EKF if necessary\n    update_home_from_EKF();\n\n    // check if we've landed or crashed\n    update_land_and_crash_detectors();\n\n#if HAL_MOUNT_ENABLED\n    // camera mount's fast update\n    camera_mount.update_fast();\n#endif\n\n    // log sensor health\n    if (should_log(MASK_LOG_ANY)) {\n        Log_Sensor_Health();\n    }\n\n    AP_Vehicle::fast_loop();\n\n    if (should_log(MASK_LOG_VIDEO_STABILISATION)) {\n        ahrs.write_video_stabilisation();\n    }\n}\n\n#if AP_SCRIPTING_ENABLED\n// start takeoff to given altitude (for use by scripting)\nbool Copter::start_takeoff(float alt)\n{\n    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    if (mode_guided.do_user_takeoff_start(alt * 100.0f)) {\n        copter.set_auto_armed(true);\n        return true;\n    }\n    return false;\n}\n\n// set target location (for use by scripting)\nbool Copter::set_target_location(const Location& target_loc)\n{\n    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    return mode_guided.set_destination(target_loc);\n}\n\n// set target position (for use by scripting)\nbool Copter::set_target_pos_NED(const Vector3f& target_pos, bool use_yaw, float yaw_deg, bool use_yaw_rate, float yaw_rate_degs, bool yaw_relative, bool terrain_alt)\n{\n    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n\n    return mode_guided.set_destination(pos_neu_cm, use_yaw, yaw_deg * 100.0, use_yaw_rate, yaw_rate_degs * 100.0, yaw_relative, terrain_alt);\n}\n\n// set target position and velocity (for use by scripting)\nbool Copter::set_target_posvel_NED(const Vector3f& target_pos, const Vector3f& target_vel)\n{\n    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f());\n}\n\n// set target position, velocity and acceleration (for use by scripting)\nbool Copter::set_target_posvelaccel_NED(const Vector3f& target_pos, const Vector3f& target_vel, const Vector3f& target_accel, bool use_yaw, float yaw_deg, bool use_yaw_rate, float yaw_rate_degs, bool yaw_relative)\n{\n    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n    const Vector3f accel_neu_cms(target_accel.x * 100.0f, target_accel.y * 100.0f, -target_accel.z * 100.0f);\n\n    return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, accel_neu_cms, use_yaw, yaw_deg * 100.0, use_yaw_rate, yaw_rate_degs * 100.0, yaw_relative);\n}\n\nbool Copter::set_target_velocity_NED(const Vector3f& vel_ned)\n{\n    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // convert vector to neu in cm\n    const Vector3f vel_neu_cms(vel_ned.x * 100.0f, vel_ned.y * 100.0f, -vel_ned.z * 100.0f);\n    mode_guided.set_velocity(vel_neu_cms);\n    return true;\n}\n\n// set target velocity and acceleration (for use by scripting)\nbool Copter::set_target_velaccel_NED(const Vector3f& target_vel, const Vector3f& target_accel, bool use_yaw, float yaw_deg, bool use_yaw_rate, float yaw_rate_degs, bool relative_yaw)\n{\n    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    // convert vector to neu in cm\n    const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f);\n    const Vector3f accel_neu_cms(target_accel.x * 100.0f, target_accel.y * 100.0f, -target_accel.z * 100.0f);\n\n    mode_guided.set_velaccel(vel_neu_cms, accel_neu_cms, use_yaw, yaw_deg * 100.0, use_yaw_rate, yaw_rate_degs * 100.0, relative_yaw);\n    return true;\n}\n\nbool Copter::set_target_angle_and_climbrate(float roll_deg, float pitch_deg, float yaw_deg, float climb_rate_ms, bool use_yaw_rate, float yaw_rate_degs)\n{\n    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    Quaternion q;\n    q.from_euler(radians(roll_deg),radians(pitch_deg),radians(yaw_deg));\n\n    mode_guided.set_angle(q, Vector3f{}, climb_rate_ms*100, false);\n    return true;\n}\n\n// circle mode controls\nbool Copter::get_circle_radius(float &radius_m)\n{\n    radius_m = circle_nav->get_radius() * 0.01f;\n    return true;\n}\n\nbool Copter::set_circle_rate(float rate_dps)\n{\n    circle_nav->set_rate(rate_dps);\n    return true;\n}\n\n// set desired speed (m/s). Used for scripting.\nbool Copter::set_desired_speed(float speed)\n{\n    // exit if vehicle is not in auto mode\n    if (!flightmode->is_autopilot()) {\n        return false;\n    }\n\n    wp_nav->set_speed_xy(speed * 100.0f);\n    return true;\n}\n\n// returns true if mode supports NAV_SCRIPT_TIME mission commands\nbool Copter::nav_scripting_enable(uint8_t mode)\n{\n    return mode == (uint8_t)mode_auto.mode_number();\n}\n\n// lua scripts use this to retrieve the contents of the active command\nbool Copter::nav_script_time(uint16_t &id, uint8_t &cmd, float &arg1, float &arg2)\n{\n    if (flightmode != &mode_auto) {\n        return false;\n    }\n\n    return mode_auto.nav_script_time(id, cmd, arg1, arg2);\n}\n\n// lua scripts use this to indicate when they have complete the command\nvoid Copter::nav_script_time_done(uint16_t id)\n{\n    if (flightmode != &mode_auto) {\n        return;\n    }\n\n    return mode_auto.nav_script_time_done(id);\n}\n\n#endif // AP_SCRIPTING_ENABLED\n\n\n// rc_loops - reads user input from transmitter/receiver\n// called at 100hz\nvoid Copter::rc_loop()\n{\n    // Read radio and 3-position switch on radio\n    // -----------------------------------------\n    read_radio();\n    rc().read_mode_switch();\n}\n\n// throttle_loop - should be run at 50 hz\n// ---------------------------\nvoid Copter::throttle_loop()\n{\n    // update throttle_low_comp value (controls priority of throttle vs attitude control)\n    update_throttle_mix();\n\n    // check auto_armed status\n    update_auto_armed();\n\n#if FRAME_CONFIG == HELI_FRAME\n    // update rotor speed\n    heli_update_rotor_speed_targets();\n\n    // update trad heli swash plate movement\n    heli_update_landing_swash();\n#endif\n\n    // compensate for ground effect (if enabled)\n    update_ground_effect_detector();\n    update_ekf_terrain_height_stable();\n}\n\n// update_batt_compass - read battery and compass\n// should be called at 10hz\nvoid Copter::update_batt_compass(void)\n{\n    // read battery before compass because it may be used for motor interference compensation\n    battery.read();\n\n    if(AP::compass().available()) {\n        // update compass with throttle value - used for compassmot\n        compass.set_throttle(motors->get_throttle());\n        compass.set_voltage(battery.voltage());\n        compass.read();\n    }\n}\n\n// Full rate logging of attitude, rate and pid loops\n// should be run at 400hz\nvoid Copter::fourhundred_hz_logging()\n{\n    if (should_log(MASK_LOG_ATTITUDE_FAST) && !copter.flightmode->logs_attitude()) {\n        Log_Write_Attitude();\n    }\n}\n\n// ten_hz_logging_loop\n// should be run at 10hz\nvoid Copter::ten_hz_logging_loop()\n{\n    // log attitude data if we're not already logging at the higher rate\n    if (should_log(MASK_LOG_ATTITUDE_MED) && !should_log(MASK_LOG_ATTITUDE_FAST) && !copter.flightmode->logs_attitude()) {\n        Log_Write_Attitude();\n    }\n    // log EKF attitude data\n    if (should_log(MASK_LOG_ATTITUDE_MED) || should_log(MASK_LOG_ATTITUDE_FAST)) {\n        Log_Write_EKF_POS();\n    }\n    if (should_log(MASK_LOG_MOTBATT)) {\n        motors->Log_Write();\n    }\n    if (should_log(MASK_LOG_RCIN)) {\n        logger.Write_RCIN();\n        if (rssi.enabled()) {\n            logger.Write_RSSI();\n        }\n    }\n    if (should_log(MASK_LOG_RCOUT)) {\n        logger.Write_RCOUT();\n    }\n    if (should_log(MASK_LOG_NTUN) && (flightmode->requires_GPS() || landing_with_GPS() || !flightmode->has_manual_throttle())) {\n        pos_control->write_log();\n    }\n    if (should_log(MASK_LOG_IMU) || should_log(MASK_LOG_IMU_FAST) || should_log(MASK_LOG_IMU_RAW)) {\n        AP::ins().Write_Vibration();\n    }\n    if (should_log(MASK_LOG_CTUN)) {\n        attitude_control->control_monitor_log();\n#if HAL_PROXIMITY_ENABLED\n        logger.Write_Proximity(g2.proximity);  // Write proximity sensor distances\n#endif\n#if BEACON_ENABLED == ENABLED\n        logger.Write_Beacon(g2.beacon);\n#endif\n    }\n#if FRAME_CONFIG == HELI_FRAME\n    Log_Write_Heli();\n#endif\n#if WINCH_ENABLED == ENABLED\n    if (should_log(MASK_LOG_ANY)) {\n        g2.winch.write_log();\n    }\n#endif\n}\n\n// twentyfive_hz_logging - should be run at 25hz\nvoid Copter::twentyfive_hz_logging()\n{\n    if (should_log(MASK_LOG_ATTITUDE_FAST)) {\n        Log_Write_EKF_POS();\n    }\n\n    if (should_log(MASK_LOG_IMU)) {\n        AP::ins().Write_IMU();\n    }\n\n#if MODE_AUTOROTATE_ENABLED == ENABLED\n    if (should_log(MASK_LOG_ATTITUDE_MED) || should_log(MASK_LOG_ATTITUDE_FAST)) {\n        //update autorotation log\n        g2.arot.Log_Write_Autorotation();\n    }\n#endif\n}\n\n// three_hz_loop - 3.3hz loop\nvoid Copter::three_hz_loop()\n{\n    // check if we've lost contact with the ground station\n    failsafe_gcs_check();\n\n    // check if we've lost terrain data\n    failsafe_terrain_check();\n\n#if AC_FENCE == ENABLED\n    // check if we have breached a fence\n    fence_check();\n#endif // AC_FENCE_ENABLED\n\n\n    // update ch6 in flight tuning\n    tuning();\n\n    // check if avoidance should be enabled based on alt\n    low_alt_avoidance();\n}\n\n// one_hz_loop - runs at 1Hz\nvoid Copter::one_hz_loop()\n{\n    if (should_log(MASK_LOG_ANY)) {\n        Log_Write_Data(LogDataID::AP_STATE, ap.value);\n    }\n\n    arming.update();\n\n    if (!motors->armed()) {\n        // make it possible to change ahrs orientation at runtime during initial config\n        ahrs.update_orientation();\n\n        update_using_interlock();\n\n        // check the user hasn't updated the frame class or type\n        motors->set_frame_class_and_type((AP_Motors::motor_frame_class)g2.frame_class.get(), (AP_Motors::motor_frame_type)g.frame_type.get());\n\n#if FRAME_CONFIG != HELI_FRAME\n        // set all throttle channel settings\n        motors->update_throttle_range();\n#endif\n    }\n\n    // update assigned functions and enable auxiliary servos\n    SRV_Channels::enable_aux_servos();\n\n    // log terrain data\n    terrain_logging();\n\n#if HAL_ADSB_ENABLED\n    adsb.set_is_flying(!ap.land_complete);\n#endif\n\n    AP_Notify::flags.flying = !ap.land_complete;\n\n    gcs().send_text(MAV_SEVERITY_CRITICAL, \"Current altitude: %.1fm\",copter.flightmode->get_alt_above_ground_cm()/100.0f);\n}\n\nvoid Copter::init_simple_bearing()\n{\n    // capture current cos_yaw and sin_yaw values\n    simple_cos_yaw = ahrs.cos_yaw();\n    simple_sin_yaw = ahrs.sin_yaw();\n\n    // initialise super simple heading (i.e. heading towards home) to be 180 deg from simple mode heading\n    super_simple_last_bearing = wrap_360_cd(ahrs.yaw_sensor+18000);\n    super_simple_cos_yaw = simple_cos_yaw;\n    super_simple_sin_yaw = simple_sin_yaw;\n\n    // log the simple bearing\n    if (should_log(MASK_LOG_ANY)) {\n        Log_Write_Data(LogDataID::INIT_SIMPLE_BEARING, ahrs.yaw_sensor);\n    }\n}\n\n// update_simple_mode - rotates pilot input if we are in simple mode\nvoid Copter::update_simple_mode(void)\n{\n    float rollx, pitchx;\n\n    // exit immediately if no new radio frame or not in simple mode\n    if (simple_mode == SimpleMode::NONE || !ap.new_radio_frame) {\n        return;\n    }\n\n    // mark radio frame as consumed\n    ap.new_radio_frame = false;\n\n    if (simple_mode == SimpleMode::SIMPLE) {\n        // rotate roll, pitch input by -initial simple heading (i.e. north facing)\n        rollx = channel_roll->get_control_in()*simple_cos_yaw - channel_pitch->get_control_in()*simple_sin_yaw;\n        pitchx = channel_roll->get_control_in()*simple_sin_yaw + channel_pitch->get_control_in()*simple_cos_yaw;\n    }else{\n        // rotate roll, pitch input by -super simple heading (reverse of heading to home)\n        rollx = channel_roll->get_control_in()*super_simple_cos_yaw - channel_pitch->get_control_in()*super_simple_sin_yaw;\n        pitchx = channel_roll->get_control_in()*super_simple_sin_yaw + channel_pitch->get_control_in()*super_simple_cos_yaw;\n    }\n\n    // rotate roll, pitch input from north facing to vehicle's perspective\n    channel_roll->set_control_in(rollx*ahrs.cos_yaw() + pitchx*ahrs.sin_yaw());\n    channel_pitch->set_control_in(-rollx*ahrs.sin_yaw() + pitchx*ahrs.cos_yaw());\n}\n\n// update_super_simple_bearing - adjusts simple bearing based on location\n// should be called after home_bearing has been updated\nvoid Copter::update_super_simple_bearing(bool force_update)\n{\n    if (!force_update) {\n        if (simple_mode != SimpleMode::SUPERSIMPLE) {\n            return;\n        }\n        if (home_distance() < SUPER_SIMPLE_RADIUS) {\n            return;\n        }\n    }\n\n    const int32_t bearing = home_bearing();\n\n    // check the bearing to home has changed by at least 5 degrees\n    if (labs(super_simple_last_bearing - bearing) < 500) {\n        return;\n    }\n\n    super_simple_last_bearing = bearing;\n    const float angle_rad = radians((super_simple_last_bearing+18000)/100);\n    super_simple_cos_yaw = cosf(angle_rad);\n    super_simple_sin_yaw = sinf(angle_rad);\n}\n\nvoid Copter::read_AHRS(void)\n{\n    // we tell AHRS to skip INS update as we have already done it in fast_loop()\n    ahrs.update(true);\n}\n\n// read baro and log control tuning\nvoid Copter::update_altitude()\n{\n    // read in baro altitude\n    read_barometer();\n\n    if (should_log(MASK_LOG_CTUN)) {\n        Log_Write_Control_Tuning();\n        AP::ins().write_notch_log_messages();\n#if HAL_GYROFFT_ENABLED\n        gyro_fft.write_log_messages();\n#endif\n    }\n}\n\n// vehicle specific waypoint info helpers\nbool Copter::get_wp_distance_m(float &distance) const\n{\n    // see GCS_MAVLINK_Copter::send_nav_controller_output()\n    distance = flightmode->wp_distance() * 0.01;\n    return true;\n}\n\n// vehicle specific waypoint info helpers\nbool Copter::get_wp_bearing_deg(float &bearing) const\n{\n    // see GCS_MAVLINK_Copter::send_nav_controller_output()\n    bearing = flightmode->wp_bearing() * 0.01;\n    return true;\n}\n\n// vehicle specific waypoint info helpers\nbool Copter::get_wp_crosstrack_error_m(float &xtrack_error) const\n{\n    // see GCS_MAVLINK_Copter::send_nav_controller_output()\n    xtrack_error = flightmode->crosstrack_error() * 0.01;\n    return true;\n}\n\n/*\n  constructor for main Copter class\n */\nCopter::Copter(void)\n    : logger(g.log_bitmask),\n    flight_modes(&g.flight_mode1),\n    simple_cos_yaw(1.0f),\n    super_simple_cos_yaw(1.0),\n    land_accel_ef_filter(LAND_DETECTOR_ACCEL_LPF_CUTOFF),\n    rc_throttle_control_in_filter(1.0f),\n    inertial_nav(ahrs),\n    param_loader(var_info),\n    flightmode(&mode_stabilize)\n{\n    // init sensor error logging flags\n    sensor_health.baro = true;\n    sensor_health.compass = true;\n}\n\nCopter copter;\nAP_Vehicle& vehicle = copter;\n\nAP_HAL_MAIN_CALLBACKS(&copter);\n"
        }
    ]
}